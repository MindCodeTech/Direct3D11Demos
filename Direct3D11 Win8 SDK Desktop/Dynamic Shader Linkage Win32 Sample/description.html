<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
    <head><link rel="stylesheet" type="text/css" href="description/Combined.css,0:ImageSprite,0:Header.NonMtps,1:LinkList;/Areas/Centers/Themes/Msdn/Content:0,/Areas/Epx/Themes/Base/Content:1&amp;amp;hashKey=991548924ACDE598A6CD2EE12DE08F79" xmlns="http://www.w3.org/1999/xhtml" />
<link rel="stylesheet" type="text/css" href="description/c7d2a7b0-7528-45b7-ab4f-1b2d6f9508f6Combined.css,0:ImageSprite,0:Footer.NonMtps,1:LinkList;/Areas/Centers/Themes/Msdn/Content:0,/Areas/Epx/Themes/Base/Content:1&amp;amp;hashKey=F66666867F6FADB76EC910ED597D6895" xmlns="http://www.w3.org/1999/xhtml" />

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Dynamic Shader Linkage Win32 Sample</title>
        <link href="description/Galleries.css" type="text/css" rel="Stylesheet" /><link href="description/Layout.css" type="text/css" rel="Stylesheet" /><link href="description/Brand.css" type="text/css" rel="Stylesheet" />
        <link href="description/iframedescription.css" rel="Stylesheet" type="text/css" />
        <script src="description/offline.js" type="text/javascript"></script>
        <style type="text/css">
            #projectInfo {
                overflow: auto;
            }
            #longDesc {
                clear:both;
                margin: 25px 0 10px 0;
            }

            #SampleIndexList{
                margin-left: 15px;
            }
        </style>
    </head>
<body>
    <div id="offlineDescription">
        <h1>Dynamic Shader Linkage Win32 Sample</h1>
        <br/>
        <div id="projectInfo">
            <div class="section">
                    <div class="itemBarLong tagsContainer">
                        <label for="Technologies">Technologies</label>
                        <div id="Technologies">
                            Win32, DirectX, DirectX SDK
                        </div>
                    </div>
                    <div class="itemBarLong tagsContainer">
                        <label for="Topics">Topics</label>
                        <div id="Topics">
                            Graphics and 3D
                        </div>
                    </div>
                <div class="itemBarLong">
                    <label for="Platforms">Platforms</label>
                    <div id="Platforms">
                        Desktop
                    </div>
                </div>
                <div class="itemBarLong">
                    <label for="Requirements">Requirements</label>
                    <div id="Requirements">
                        
                    </div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Primary language</label>
                    <div id="LastUpdated">en-US</div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Last updated</label>
                    <div id="LastUpdated">9/16/2013</div>
                </div>
                <div class="itemBarLong">
                    <label for="License">License</label>
                    <div id="License">
                        <a href="license.rtf">MS-LPL</a></div>
                </div>
                <div class="itemBar">
                    <div class="viewonlinecont">
                        <a data-link="online" href="http://code.msdn.microsoft.com/Dynamic-Shader-Linkage-504eda2d">View this sample online</a>
                    </div>
                </div>
            </div>
        </div>
        
                   
<script type="text/javascript">
    function initializePage() {
        var otherTabClass = 'otherTab';
        var hiddenPreClass = 'hidden';

        var htmlDecode = function(encodedData) {
            var decodedData = "";
            if (encodedData) {
                var div = document.createElement('div');
                div.innerHTML = encodedData;
                decodedData = div.firstChild.nodeValue.replace( /\\r\\n/ig , '\r\n');
            }
            return decodedData;
        };
                
        Galleries.iterateElem(Galleries.findElem(null, 'div', 'scriptcode'), function (index, scriptBlock) {
            var titleElem = Galleries.findElem(scriptBlock, 'div', 'title')[0];
            var labelElems = Galleries.findElem(titleElem, 'span');
            if (labelElems.length == 0) {
                labelElems = titleElem;
            }
            var languageSpans = Galleries.findElem(scriptBlock, 'span', 'hidden');
            var pres = Galleries.findElem(scriptBlock, 'pre');
            if (languageSpans.length > 0 && pres.length > 1) {
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    var languageSpan = languageSpans[index];
                            
                    elem.code = codePre.innerHTML.replace( /(\r(\n)?)|((\r)?\n)/ig , '\\r\\n');
                            
                    codePre.className = codePre.className.replace(hiddenPreClass, '');
                            
                    languageSpan.parentNode.removeChild(languageSpan);
                });

                pres = Galleries.findElem(scriptBlock, 'pre');
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    if (index == 0) {
                        scriptBlock.activeTab = 0;
                    }
                    else {
                        labelSpan.className += otherTabClass;
                        codePre.className += hiddenPreClass;
                    }
                    Galleries.attachEventHandler(labelSpan, 'click', function(e) {
                        var activeTab = scriptBlock.activeTab;
                        labelElems[activeTab].className += otherTabClass;
                        pres[activeTab].className += hiddenPreClass;

                        codePre.className = codePre.className.replace(hiddenPreClass, '');
                        labelSpan.className = labelSpan.className.replace(otherTabClass, '');
                        scriptBlock.activeTab = index;
                    });
                });

                var preview = Galleries.findElem(scriptBlock, 'div', 'preview');
                if (preview.length == 0) {
                    preview.push(pres[pres.length - 1]);
                }
                Galleries.iterateElem(preview, function(index, elem) {
                    elem.parentNode.removeChild(elem);
                });

                if (window.clipboardData && clipboardData.setData) {
                    var copyLink = document.createElement('a');
                    copyLink.href = 'javascript:void(0);';
                    copyLink.className = 'copyCode';
                    copyLink.innerHTML = 'Copy code';
                    Galleries.attachEventHandler(copyLink, 'click', function (e) {
                        clipboardData.setData("Text", htmlDecode(labelElems[scriptBlock.activeTab].code));
                        return false;
                    });
                    scriptBlock.insertBefore(copyLink, scriptBlock.childNodes[0]);
                }
            }
        });
    }

    Galleries.onWindowLoad(function(){
        initializePage();
    });

</script>
<div id="longDesc">
    
<p>This is the DirectX SDK's DynamicShaderLinkage11 sample updated to use Visual Studio 2012 and the Windows SDK 8.0 without any dependencies on legacy DirectX SDK content. This sample is a Win32 desktop DirectX 11.0 application for Windows 8, Windows 7, and
 Windows Vista Service Pack 2 with the DirectX 11.0 runtime.&nbsp;</p>
<p><strong>This is based on the the legacy DirectX SDK (June 2010) Win32 desktop sample running on Windows Vista, Windows 7, and Windows 8. This is not intended for use with Windows Store apps or Windows RT, although the techniques shown are applicable.</strong></p>
<h1><span style="font-size:20px; font-weight:bold">Description</span></h1>
<p>This Direct3D 11 sample demonstrates use of Shader Model 5 shader interfaces and Direct3D 11 support for linking shader interface methods at runtime.</p>
<p><em>This sample uses the&nbsp;<a href="http://go.microsoft.com/fwlink/?LinkId=320437">DXUT for Direct3D 11</a>&nbsp;framework for Win32 desktop applications. There is an
<a href="http://code.msdn.microsoft.com/Effects-11-Win32-Samples-cce82a4d">Effects 11 version
</a>of this sample as well. This sample requires Feature Level 11.0 or better to function.</em></p>
<h2><img id="96133" src="description/DynamicShaderLinkage11.JPG" alt="" width="116" height="91"></h2>
<h2>Coping With The Shader Permutation Explosion</h2>
<p>Rendering systems need to deal with a wide range of complexity when managing shaders while providing the greatest possible opportunity to optimize shader code. This becomes an even greater challenge when you factor in the need to support a variety of different
 materials in a rendered scene across the broad range of available hardware configurations. To address these challenges, shader developers have often resorted to one of two general approaches. Either creating fully featured &quot;uber-shaders&quot; which trade off some
 performance for flexibility or specifically creating individual shaders for each geometry stream, material type or light type combination needed.</p>
<p>Uber-shaders handle this combinatorial problem by recompiling the same shader with different preprocessor defines, while the latter method uses brute-force developer power to the same end. This shader permutation explosion has often been a problem for developers
 who must now manage thousands of different shader permutations within their game and asset pipeline.</p>
<p>Direct3D 11 and shader model 5 introduces Object Oriented language constructs and provides runtime support of shader linking to assist developers in tackling these development problems. This sample uses shader interfaces to help manage the number of shader
 permutations created.</p>
<h2>Shader Model 5 Interfaces and Classes</h2>
<p>In the pixel shader, we first define base interfaces for different light and material types:</p>
<pre>&nbsp;&nbsp; //--------------------------------------------------------------------------------------<br>&nbsp;&nbsp; // Interfaces<br>&nbsp;&nbsp; //--------------------------------------------------------------------------------------<br>&nbsp;&nbsp; interface iBaseLight<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; float3 IlluminateAmbient(float3 vNormal);</pre>
<pre>&nbsp;&nbsp; float3 IlluminateDiffuse(float3 vNormal);</pre>
<pre>&nbsp;&nbsp; float3 IlluminateSpecular(float3 vNormal, int specularPower );</pre>
<pre>&nbsp;&nbsp; };<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; // ...<br>&nbsp;&nbsp; interface iBaseMaterial<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; float3 GetAmbientColor(float2 vTexcoord);</pre>
<pre>&nbsp;&nbsp; float3 GetDiffuseColor(float2 vTexcoord);</pre>
<pre>&nbsp;&nbsp; int GetSpecularPower();</pre>
<pre>&nbsp;&nbsp; };</pre>
<pre>&nbsp;&nbsp; // ...</pre>
<p>Next we build specialized classes based on these interfaces, adding to the functionality where needed:</p>
<pre>//--------------------------------------------------------------------------------------
// Classes
//--------------------------------------------------------------------------------------
class cAmbientLight : iBaseLight
{
   float3&nbsp;m_vLightColor;
   bool&nbsp;&nbsp;&nbsp;&nbsp; m_bEnable;</pre>
<pre>&nbsp;&nbsp; float3 IlluminateAmbient(float3 vNormal);</pre>
<pre>&nbsp;&nbsp; float3 IlluminateDiffuse(float3 vNormal);</pre>
<pre>&nbsp;&nbsp; float3 IlluminateSpecular(float3 vNormal, int specularPower );<br>
&nbsp;&nbsp; };</pre>
<pre>&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp; class cBaseMaterial : iBaseMaterial
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; float3&nbsp;m_vColor;<br>
&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_iSpecPower;</pre>
<pre>&nbsp;&nbsp; float3 GetAmbientColor(float2 vTexcoord);</pre>
<pre>&nbsp;&nbsp; float3 GetDiffuseColor(float2 vTexcoord);
&nbsp; 
&nbsp;&nbsp; int GetSpecularPower();</pre>
<pre>&nbsp;&nbsp; };<br>
&nbsp;&nbsp; // ....</pre>
<h2>Abstract Instances and The Shaders Main Function</h2>
<p>The pixel shaders main function uses abstract instances of the interfaces for computation. These interfaces instances are made concrete by the application code at shader bind time:</p>
<pre style="padding-left:30px">//--------------------------------------------------------------------------------------<br>// Abstract Interface Instances for dyamic linkage / permutation<br>//--------------------------------------------------------------------------------------<br>iBaseLight&nbsp;&nbsp;&nbsp;&nbsp; g_abstractAmbientLighting;<br>iBaseLight&nbsp;&nbsp;&nbsp;&nbsp; g_abstractDirectLighting;<br>iBaseMaterial&nbsp; g_abstractMaterial;</pre>
<pre style="padding-left:30px">//--------------------------------------------------------------------------------------<br>// Pixel Shader<br>//--------------------------------------------------------------------------------------<br>float4 PSMain( PS_INPUT Input ) : SV_TARGET<br>{<br>    // Compute the Ambient term<br>    float3&nbsp;&nbsp; Ambient = (float3)0.0f;</pre>
<pre style="padding-left:30px">    Ambient = g_abstractMaterial.GetAmbientColor( Input.vTexcoord ) * g_abstractAmbientLighting.IlluminateAmbient( Input.vNormal );</pre>
<pre style="padding-left:30px">    // Accumulate the Diffuse contribution<br>    float3&nbsp;&nbsp; Diffuse = (float3)0.0f;</pre>
<pre style="padding-left:30px">    Diffuse &#43;= g_abstractMaterial.GetDiffuseColor( Input.vTexcoord ) * g_abstractDirectLighting.IlluminateDiffuse( Input.vNormal );</pre>
<pre style="padding-left:30px">    // Compute the Specular contribution<br>    float3&nbsp;&nbsp; Specular = (float3)0.0f;<br>    Specular &#43;= g_abstractDirectLighting.IlluminateSpecular( Input.vNormal, g_abstractMaterial.GetSpecularPower() );</pre>
<pre style="padding-left:30px">    // Accumulate the lighting with saturation<br>    float3 Lighting = saturate( Ambient &#43; Diffuse &#43; Specular );</pre>
<pre style="padding-left:30px">return float4(Lighting,1.0f);<br>
}</pre>
<p>Here we are simply accumulating the lighting for the pixel across the generic / abstract light instances.</p>
<h1>Application Code and Shader Interfaces</h1>
<p>Once the shader has been compiled and loaded, the sample application code makes use of the shader reflection layer to acquire both the concrete and abstract shader class instance offsets within the compiled shader. These offsets are then used to dynamically
 configure the shader code path according to user selected options. The linkage happens directly in the Direct3D 11 runtime and is specified during the PSSetShader call</p>
<h2>Acquisition of the Shader Interfaces</h2>
<p>After shader compilation we must acquire the offsets for the abstract instances of our permutable shader objects:</p>
<pre>// use shader reflection to get data locations for the interface array<br>ID3D11ShaderReflection* pReflector = NULL;<br>V_RETURN( D3DReflect( pPixelShaderBuffer-&gt;GetBufferPointer(), pPixelShaderBuffer-&gt;GetBufferSize(),<br>IID_ID3D11ShaderReflection, (void**) &amp;pReflector) );</pre>
<pre>g_iNumPSInterfaces = pReflector-&gt;GetNumInterfaceSlots();<br>g_dynamicLinkageArray = (ID3D11ClassInstance**) malloc( sizeof(ID3D11ClassInstance*) * g_iNumPSInterfaces );<br>if (g_dynamicLinkageArray == NULL)<br>return E_FAIL;</pre>
<pre>ID3D11ShaderReflectionVariable* pAmbientLightingVar = pReflector-&gt;GetVariableByName(&quot;g_abstractAmbientLighting&quot;);<br>g_iAmbientLightingOffset = pAmbientLightingVar-&gt;GetInterfaceSlot(0);</pre>
<pre>ID3D11ShaderReflectionVariable* pDirectLightingVar = pReflector-&gt;GetVariableByName(&quot;g_abstractDirectLighting&quot;);<br>g_iDirectLightingOffset = pDirectLightingVar-&gt;GetInterfaceSlot(0);</pre>
<pre>ID3D11ShaderReflectionVariable* pMaterialVar = pReflector-&gt;GetVariableByName(&quot;g_abstractMaterial&quot;);<br>g_iMaterialOffset = pMaterialVar-&gt;GetInterfaceSlot(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>// ...</pre>
<p>Next we enumerate all possible permutations of material object that exist in the shader:</p>
<pre>// Material Dynamic Permutation<br>enum E_MATERIAL_TYPES<br>{<br>&nbsp;&nbsp; MATERIAL_PLASTIC,<br>&nbsp;&nbsp; MATERIAL_PLASTIC_TEXTURED,<br>&nbsp;&nbsp; MATERIAL_PLASTIC_LIGHTING_ONLY,</pre>
<pre>&nbsp;&nbsp; MATERIAL_ROUGH,<br>&nbsp;&nbsp; MATERIAL_ROUGH_TEXTURED,<br>&nbsp;&nbsp; MATERIAL_ROUGH_LIGHTING_ONLY,</pre>
<pre>&nbsp;&nbsp; MATERIAL_TYPE_COUNT<br>};<br>char*&nbsp; g_pMaterialClassNames[ MATERIAL_TYPE_COUNT ] =<br>{<br>&nbsp;&nbsp; &quot;g_plasticMaterial&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cPlasticMaterial<br>&nbsp;&nbsp; &quot;g_plasticTexturedMaterial&quot;,&nbsp;&nbsp;&nbsp;&nbsp; // cPlasticTexturedMaterial<br>&nbsp;&nbsp; &quot;g_plasticLightingOnlyMaterial&quot;, // cPlasticLightingOnlyMaterial<br>&nbsp;&nbsp; &quot;g_roughMaterial&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cRoughMaterial<br>&nbsp;&nbsp; &quot;g_roughTexturedMaterial&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cRoughTexturedMaterial<br>&nbsp;&nbsp; &quot;g_roughLightingOnlyMaterial&quot;&nbsp;&nbsp;&nbsp; // cRoughLightingOnlyMaterial<br>};<br>E_MATERIAL_TYPES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_iMaterial = MATERIAL_PLASTIC_TEXTURED;</pre>
<pre><br>// ...</pre>
<pre>// Acquire the material Class Instances for all possible material settings<br>for( UINT i=0; i &lt; MATERIAL_TYPE_COUNT; i&#43;&#43;)<br>{<br>&nbsp;&nbsp; g_pPSClassLinkage-&gt;GetClassInstance( g_pMaterialClassNames[i], 0, &amp;g_pMaterialClasses[i] );<br>}</pre>
<h2>Specifying Linkage to the Runtime</h2>
<p>Users specify the specific lighting and material configuration through the samples user interface. In the application code, at Shader bind time the following selectively sets shader code bindings according to user specified settings:</p>
<pre>// Setup the Shader Linkage based on the user settings for Lighting<br>&nbsp;&nbsp;&nbsp; // Ambient Lighting First - Constant or Hemi?<br>&nbsp;&nbsp;&nbsp; if ( g_bHemiAmbientLighting )<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iAmbientLightingOffset] = g_pHemiAmbientLightClass;<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iAmbientLightingOffset] = g_pAmbientLightClass;</pre>
<pre>&nbsp;&nbsp;&nbsp; // Direct Light - None or Directional TODO: or Spot or Environment?<br>&nbsp;&nbsp;&nbsp; if (g_bDirectLighting)<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iDirectLightingOffset] = g_pDirectionalLightClass;<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iDirectLightingOffset] = g_pAmbientLightClass;</pre>
<pre><br>&nbsp;&nbsp;&nbsp; // Use the selected material class instance<br>&nbsp;&nbsp;&nbsp; if (g_bLightingOnly)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; switch( g_iMaterial )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; case MATERIAL_PLASTIC:<br>&nbsp;&nbsp;&nbsp; case MATERIAL_PLASTIC_TEXTURED:<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iMaterialOffset] = g_pMaterialClasses[ MATERIAL_PLASTIC_LIGHTING_ONLY ];<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case MATERIAL_ROUGH:<br>&nbsp;&nbsp;&nbsp; case MATERIAL_ROUGH_TEXTURED:<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iMaterialOffset] = g_pMaterialClasses[ MATERIAL_ROUGH_LIGHTING_ONLY ];<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; g_dynamicLinkageArray[g_iMaterialOffset] =&nbsp;&nbsp;&nbsp;&nbsp; g_pMaterialClasses[ g_iMaterial ] ;<br>&nbsp;</pre>
<p>The Direct3D 11 runtime efficiently links each of the selected methods at source level, inlining and optimizing the shader code as much as possible to provide an optimal shader for the GPU to execute.&nbsp;</p>
<h1>Dependancies</h1>
<p>DXUT-based samples typically make use of runtime HLSL compilation. Build-time compilation is recommended for all production Direct3D applications, but for experimentation and samples development runtime HLSL compiliation is preferred. Therefore, the D3DCompile*.DLL
 must be available in the search path when this program is executed.</p>
<ul>
<li>When using the Windows 8.x SDK and targeting Windows Vista or later, you can include the D3DCompile_46 or D3DCompile_47 DLL side-by-side with your application copying the file from the REDIST folder.
</li></ul>
<pre style="padding-left:60px">%ProgramFiles(x86)%\Windows kits\8.0\Redist\D3D\arm, x86 or x64</pre>
<pre style="padding-left:60px">%ProgramFiles(x86)%\Windows kits\8.1\Redist\D3D\arm, x86 or x64</pre>
<h1>Building with Visual Studio 2010</h1>
<p>The code in this sample can be built using Visual Studio 2010 rather than Visual Studio 2012. The changes required are:</p>
<ul>
<li>Change the Platform Toolset to &quot;v100&quot; </li><li>Obtain the <a href="http://msdn.microsoft.com/en-us/windows/hardware/hh852363">
Windows SDK 8.0</a> </li><li>Use the <a href="http://blogs.msdn.com/b/vcblog/archive/2012/11/23/using-the-windows-8-sdk-with-visual-studio-2010-configuring-multiple-projects.aspx">
instructions </a>for adding the Windows 8.0 SDK headers for VS 2010 projects </li></ul>
<h1>More Information</h1>
<p><a href="http://blogs.msdn.com/b/chuckw/archive/2012/03/22/where-is-the-directx-sdk.aspx">Where is the DirectX SDK?</a></p>
<p><a href="http://blogs.msdn.com/b/chuckw/archive/2013/07/01/where-is-the-directx-sdk-2013-edition.aspx">Where is the DirectX SDK (2013 Edition)?</a>&nbsp;</p>
<p><a href="http://blogs.msdn.com/b/chuckw/archive/2013/09/14/dxut-for-win32-desktop-update.aspx">DXUT for Win32 Desktop Update</a></p>
<p><a href="http://blogs.msdn.com/b/chuckw/">Games for Windows and DirectX SDK blog</a></p>

</div>


    </div>
</body>
</html>
